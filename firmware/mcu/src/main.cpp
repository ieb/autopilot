/**
 * IMU Sensor Fusion MCU Firmware
 * ==============================
 *
 * ATtiny3226 firmware for ICM-20948 9-DoF IMU with Madgwick AHRS filter.
 * Outputs fused orientation data over serial at 100Hz.
 *
 * Serial Protocol:
 *   $IMU,heading,pitch,roll,yaw_rate,pitch_rate,roll_rate,ax,ay,az*checksum\r\n
 *
 * All angles in degrees, rates in deg/s, accelerations in m/s²
 * Checksum is XOR of all characters between $ and * (exclusive)
 *
 * Commands (received on serial):
 *   $CAL,START*XX - Start magnetometer calibration
 *   $CAL,SAVE*XX  - Save calibration to EEPROM
 *   $CFG,RATE,<hz>*XX - Set output rate
 */

#include <Arduino.h>
#include <EEPROM.h>
#include <Wire.h>

#include "ICM20948.h"
#include "MadgwickAHRS.h"
#include "config.h"

// Version info (generated by build)
#include "version.h"

// ============================================================================
// Configuration
// ============================================================================

#ifndef IMU_UPDATE_RATE_HZ
#define IMU_UPDATE_RATE_HZ 100
#endif

#ifndef SERIAL_OUTPUT_RATE_HZ
#define SERIAL_OUTPUT_RATE_HZ 100
#endif

#ifndef DEBUG_EN
#define DEBUG_EN 0
#endif

// Timing
const uint32_t IMU_UPDATE_INTERVAL_US = 1000000UL / IMU_UPDATE_RATE_HZ;
const uint32_t SERIAL_OUTPUT_INTERVAL_US = 1000000UL / SERIAL_OUTPUT_RATE_HZ;

// ============================================================================
// Global Objects
// ============================================================================

ICM20948 imu;
Madgwick filter;

// Timing
uint32_t lastIMUUpdate = 0;
uint32_t lastSerialOutput = 0;
uint32_t loopCount = 0;

// Calibration state
bool calibrating = false;
uint32_t calibrationStartTime = 0;

// Magnetometer calibration (stored in EEPROM)
struct MagCalibration {
  float offsetX, offsetY, offsetZ;
  float scaleX, scaleY, scaleZ;
  uint16_t magic; // 0xCAFE if valid
};

MagCalibration magCal;
const uint16_t CAL_MAGIC = 0xCAFE;

// Calibration min/max during calibration process
float magMin[3], magMax[3];

// ============================================================================
// Function Declarations
// ============================================================================

void setupIMU();
void loadCalibration();
void saveCalibration();
void startCalibration();
void updateCalibration(float mx, float my, float mz);
void finishCalibration();
void processCommands();
void outputIMUData();
uint8_t computeChecksum(const char *str);

// ============================================================================
// Setup
// ============================================================================

void setup() {
  // Initialize serial
  Serial.begin(115200);
  while (!Serial && millis() < 1000) {
    ; // Wait for serial (with timeout)
  }

#if DEBUG_EN
  Serial.println(F("IMU MCU Starting..."));
  Serial.print(F("Version: "));
  Serial.println(GIT_SHA1_VERSION);
#endif

  // Initialize I2C
  Wire.begin();
  Wire.setClock(400000); // 400kHz I2C

  // Load calibration from EEPROM
  loadCalibration();

  // Initialize IMU
  setupIMU();

  // Initialize Madgwick filter
  filter.begin(IMU_UPDATE_RATE_HZ);

#if DEBUG_EN
  Serial.println(F("IMU MCU Ready"));
#endif
}

// ============================================================================
// Main Loop
// ============================================================================

void loop() {
  uint32_t now = micros();

  // Process incoming commands
  processCommands();

  // Update IMU at target rate
  if (now - lastIMUUpdate >= IMU_UPDATE_INTERVAL_US) {
    lastIMUUpdate = now;

    // Read raw sensor data
    if (imu.dataReady()) {
      imu.read();

      // Get scaled values
      float ax = imu.accelX(); // g
      float ay = imu.accelY();
      float az = imu.accelZ();

      float gx = imu.gyroX(); // deg/s
      float gy = imu.gyroY();
      float gz = imu.gyroZ();

      float mx = imu.magX(); // uT
      float my = imu.magY();
      float mz = imu.magZ();

      // Apply magnetometer calibration
      if (!calibrating && magCal.magic == CAL_MAGIC) {
        mx = (mx - magCal.offsetX) * magCal.scaleX;
        my = (my - magCal.offsetY) * magCal.scaleY;
        mz = (mz - magCal.offsetZ) * magCal.scaleZ;
      } else if (calibrating) {
        updateCalibration(mx, my, mz);
      }

      // Update Madgwick filter
      // Note: Madgwick expects gyro in rad/s, but our version handles deg/s
      filter.update(gx, gy, gz, ax, ay, az, mx, my, mz);

      loopCount++;
    }
  }

  // Output at specified rate
  if (now - lastSerialOutput >= SERIAL_OUTPUT_INTERVAL_US) {
    lastSerialOutput = now;
    outputIMUData();
  }
}

// ============================================================================
// IMU Setup
// ============================================================================

void setupIMU() {
#if DEBUG_EN
  Serial.println(F("Initializing ICM-20948..."));
#endif

  // Initialize with default I2C address (0x68 or 0x69)
  if (!imu.begin()) {
#if DEBUG_EN
    Serial.println(F("ICM-20948 not found!"));
#endif
    // Blink LED to indicate error
    while (1) {
      delay(500);
    }
  }

  // Configure accelerometer: ±4g range
  imu.setAccelRange(ICM20948_ACCEL_RANGE_4G);

  // Configure gyroscope: ±500 deg/s range
  imu.setGyroRange(ICM20948_GYRO_RANGE_500DPS);

  // Configure sample rate
  imu.setSampleRate(IMU_UPDATE_RATE_HZ);

  // Enable magnetometer
  imu.enableMagnetometer();

#if DEBUG_EN
  Serial.println(F("ICM-20948 initialized"));
#endif
}

// ============================================================================
// Calibration
// ============================================================================

void loadCalibration() {
  EEPROM.get(0, magCal);

  if (magCal.magic != CAL_MAGIC) {
    // No valid calibration, use defaults
    magCal.offsetX = magCal.offsetY = magCal.offsetZ = 0;
    magCal.scaleX = magCal.scaleY = magCal.scaleZ = 1.0;

#if DEBUG_EN
    Serial.println(F("No calibration found"));
#endif
  } else {
#if DEBUG_EN
    Serial.println(F("Calibration loaded"));
    Serial.print(F("Offsets: "));
    Serial.print(magCal.offsetX);
    Serial.print(F(", "));
    Serial.print(magCal.offsetY);
    Serial.print(F(", "));
    Serial.println(magCal.offsetZ);
#endif
  }
}

void saveCalibration() {
  magCal.magic = CAL_MAGIC;
  EEPROM.put(0, magCal);

#if DEBUG_EN
  Serial.println(F("Calibration saved"));
#endif
}

void startCalibration() {
  calibrating = true;
  calibrationStartTime = millis();

  // Reset min/max
  magMin[0] = magMin[1] = magMin[2] = 99999;
  magMax[0] = magMax[1] = magMax[2] = -99999;

#if DEBUG_EN
  Serial.println(F("Calibration started - rotate sensor slowly"));
#endif
}

void updateCalibration(float mx, float my, float mz) {
  // Track min/max for each axis
  if (mx < magMin[0])
    magMin[0] = mx;
  if (mx > magMax[0])
    magMax[0] = mx;
  if (my < magMin[1])
    magMin[1] = my;
  if (my > magMax[1])
    magMax[1] = my;
  if (mz < magMin[2])
    magMin[2] = mz;
  if (mz > magMax[2])
    magMax[2] = mz;

  // Auto-finish after 30 seconds
  if (millis() - calibrationStartTime > 30000) {
    finishCalibration();
  }
}

void finishCalibration() {
  calibrating = false;

  // Calculate hard-iron offsets (center of min/max)
  magCal.offsetX = (magMin[0] + magMax[0]) / 2;
  magCal.offsetY = (magMin[1] + magMax[1]) / 2;
  magCal.offsetZ = (magMin[2] + magMax[2]) / 2;

  // Calculate soft-iron scale factors
  float rangeX = magMax[0] - magMin[0];
  float rangeY = magMax[1] - magMin[1];
  float rangeZ = magMax[2] - magMin[2];
  float avgRange = (rangeX + rangeY + rangeZ) / 3;

  magCal.scaleX = avgRange / rangeX;
  magCal.scaleY = avgRange / rangeY;
  magCal.scaleZ = avgRange / rangeZ;

#if DEBUG_EN
  Serial.println(F("Calibration complete"));
  Serial.print(F("Offsets: "));
  Serial.print(magCal.offsetX);
  Serial.print(F(", "));
  Serial.print(magCal.offsetY);
  Serial.print(F(", "));
  Serial.println(magCal.offsetZ);
  Serial.print(F("Scales: "));
  Serial.print(magCal.scaleX);
  Serial.print(F(", "));
  Serial.print(magCal.scaleY);
  Serial.print(F(", "));
  Serial.println(magCal.scaleZ);
#endif
}

// ============================================================================
// Serial Output
// ============================================================================

void outputIMUData() {
  // Get orientation from filter
  float heading = filter.getYaw(); // 0-360 degrees
  float pitch = filter.getPitch(); // -90 to +90 degrees
  float roll = filter.getRoll();   // -180 to +180 degrees

  // Get rates directly from gyro (already in deg/s)
  float yawRate = imu.gyroZ();
  float pitchRate = imu.gyroY();
  float rollRate = imu.gyroX();

  // Get accelerations in m/s² (convert from g)
  float ax = imu.accelX() * 9.81;
  float ay = imu.accelY() * 9.81;
  float az = imu.accelZ() * 9.81;

  // Format message (without $ and checksum first)
  char msg[128];
  char payload[120];

  // Build payload
  snprintf(payload, sizeof(payload),
           "IMU,%.1f,%.1f,%.1f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f", heading, pitch,
           roll, yawRate, pitchRate, rollRate, ax, ay, az);

  // Compute checksum
  uint8_t checksum = computeChecksum(payload);

  // Build final message
  snprintf(msg, sizeof(msg), "$%s*%02X\r\n", payload, checksum);

  // Send
  Serial.print(msg);
}

uint8_t computeChecksum(const char *str) {
  uint8_t checksum = 0;
  while (*str) {
    checksum ^= *str++;
  }
  return checksum;
}

// ============================================================================
// Command Processing
// ============================================================================

void processCommands() {
  static char cmdBuffer[64];
  static uint8_t cmdIndex = 0;

  while (Serial.available()) {
    char c = Serial.read();

    if (c == '$') {
      // Start of command
      cmdIndex = 0;
    } else if (c == '\n' || c == '\r') {
      // End of command
      cmdBuffer[cmdIndex] = '\0';

      // Parse command
      if (strncmp(cmdBuffer, "CAL,START", 9) == 0) {
        startCalibration();
      } else if (strncmp(cmdBuffer, "CAL,SAVE", 8) == 0) {
        saveCalibration();
      } else if (strncmp(cmdBuffer, "CAL,STOP", 8) == 0) {
        finishCalibration();
      }

      cmdIndex = 0;
    } else if (cmdIndex < sizeof(cmdBuffer) - 1) {
      cmdBuffer[cmdIndex++] = c;
    }
  }
}
