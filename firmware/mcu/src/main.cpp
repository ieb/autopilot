/**
 * IMU Sensor Fusion MCU Firmware
 * ==============================
 *
 * ATtiny3224/3226 firmware for ICM-20948 9-DoF IMU with Madgwick AHRS filter.
 * Outputs fused orientation data over serial at 100Hz.
 *
 * Uses a three-phase simplex protocol:
 *   1. STARTUP: Initialize hardware, send version and ready prompt
 *   2. CONFIG: Receive configuration from Pi (mag cal, offset, etc.)
 *   3. STREAMING: Send IMU data only (simplex mode, no command processing)
 *
 * This enables simplex RS-485 communication after configuration.
 * To reconfigure, power cycle the IMU.
 *
 * Startup Sequence (IMU -> Pi):
 *   $VER,<version>*XX  - Firmware version
 *   $RDY*XX            - Ready for configuration
 *
 * Configuration Commands (Pi -> IMU):
 *   $OFF,x,y,z*XX      - Set mounting offset (meters)
 *   $MAG,ox,oy,oz,sx,sy,sz*XX - Set magnetometer calibration
 *   $CAL,START*XX      - Start interactive mag calibration
 *   $CAL,STOP*XX       - Stop calibration, return values
 *   $START*XX          - Begin streaming (enter simplex mode)
 *
 * Configuration Responses (IMU -> Pi):
 *   $ACK*XX            - Command accepted
 *   $OFS,x,y,z*XX      - Offset confirmation
 *   $MGC,ox,oy,oz,sx,sy,sz*XX - Mag cal values
 *   $ERR,msg*XX        - Error message
 *
 * Streaming Output (IMU -> Pi):
 *   $IMU,heading,pitch,roll,yaw_rate,pitch_rate,roll_rate,ax,ay,az*XX
 *
 * All angles in degrees, rates in deg/s, accelerations in m/s²
 * Checksum is XOR of all characters between $ and * (exclusive)
 */

#include <Arduino.h>
#include <Wire.h>

#include "ICM20948.h"
#include "MadgwickAHRS.h"
#include "config.h"

// Version info (generated by build)
#include "version.h"

// ============================================================================
// State Machine
// ============================================================================

enum class IMUState {
  STARTUP,
  WAITING_FOR_CONFIG,
  CALIBRATING,
  STREAMING,
  ERROR
};

IMUState currentState = IMUState::STARTUP;

// ============================================================================
// Configuration
// ============================================================================

#ifndef IMU_UPDATE_RATE_HZ
#define IMU_UPDATE_RATE_HZ 100
#endif

#ifndef SERIAL_OUTPUT_RATE_HZ
#define SERIAL_OUTPUT_RATE_HZ 100
#endif

#ifndef DEBUG_EN
#define DEBUG_EN 0
#endif

// Configuration timeout (30 seconds)
#ifndef CONFIG_TIMEOUT_MS
#define CONFIG_TIMEOUT_MS 30000
#endif

// Timing
const uint32_t IMU_UPDATE_INTERVAL_US = 1000000UL / IMU_UPDATE_RATE_HZ;
const uint32_t SERIAL_OUTPUT_INTERVAL_US = 1000000UL / SERIAL_OUTPUT_RATE_HZ;

// ============================================================================
// Global Objects
// ============================================================================

ICM20948 imu;
Madgwick filter;

// Timing
uint32_t lastIMUUpdate = 0;
uint32_t lastSerialOutput = 0;
uint32_t loopCount = 0;
uint32_t configTimeoutStart = 0;

// Calibration state
bool calibrating = false;
uint32_t calibrationStartTime = 0;

// Magnetometer calibration (received from Pi at startup)
struct MagCalibration {
  float offsetX, offsetY, offsetZ;
  float scaleX, scaleY, scaleZ;
  bool valid;
};

MagCalibration magCal = {0, 0, 0, 1.0f, 1.0f, 1.0f, false};

// Calibration min/max during calibration process
float magMin[3], magMax[3];

// IMU mounting offset (received from Pi at startup)
// Compensates for centripetal/tangential acceleration when IMU is off-center
struct OffsetCalibration {
  float x, y, z;    // meters from center of rotation
};

OffsetCalibration offsetCal = {0, 0, 0};

// Previous gyro readings for angular acceleration calculation
float prevGyroX = 0, prevGyroY = 0, prevGyroZ = 0;
uint32_t prevGyroTime = 0;

// Command buffer
static char cmdBuffer[128];
static uint8_t cmdIndex = 0;

// ============================================================================
// Function Declarations
// ============================================================================

void setupIMU();
void sendVersion();
void sendReady();
void sendAck();
void sendError(const char *msg);
void sendMagCalValues();
void sendOffsetResponse();
void startCalibration();
void updateCalibration(float mx, float my, float mz);
void finishCalibration();
void processConfigCommands();
void checkConfigTimeout();
void blinkErrorLED();
void updateIMU();
void outputIMUData();
void correctAccelForOffset(float &ax, float &ay, float &az,
                           float gx, float gy, float gz,
                           float alpha_x, float alpha_y, float alpha_z);
uint8_t computeChecksum(const char *str);
void sendMessage(const char *payload);

// ============================================================================
// Setup
// ============================================================================

void setup() {
  // Initialize LED for status indication
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  // Initialize serial
  Serial.begin(115200);
  while (!Serial && millis() < 1000) {
    ; // Wait for serial (with timeout)
  }

  // Initialize I2C
  Wire.begin();
  Wire.setClock(400000); // 400kHz I2C

  // Initialize IMU hardware
  setupIMU();

  // Initialize Madgwick filter
  filter.begin(IMU_UPDATE_RATE_HZ);

  // LED on to indicate hardware ready
  digitalWrite(LED_PIN, HIGH);

  // Send startup sequence
  delay(100);  // Brief delay to ensure serial is ready
  sendVersion();
  sendReady();

  // Enter config wait state
  currentState = IMUState::WAITING_FOR_CONFIG;
  configTimeoutStart = millis();
}

// ============================================================================
// Main Loop
// ============================================================================

void loop() {
  switch (currentState) {
    case IMUState::STARTUP:
      // Should not reach here, handled in setup()
      break;

    case IMUState::WAITING_FOR_CONFIG:
      processConfigCommands();
      checkConfigTimeout();
      break;

    case IMUState::CALIBRATING:
      updateIMU();  // Keep updating IMU during calibration
      processConfigCommands();  // Accept CAL,STOP
      break;

    case IMUState::STREAMING:
      // Simplex mode - only output data, no command processing
      {
        uint32_t now = micros();

        // Update IMU at target rate
        if (now - lastIMUUpdate >= IMU_UPDATE_INTERVAL_US) {
          lastIMUUpdate = now;
          updateIMU();
        }

        // Output at specified rate
        if (now - lastSerialOutput >= SERIAL_OUTPUT_INTERVAL_US) {
          lastSerialOutput = now;
          outputIMUData();
        }
      }
      break;

    case IMUState::ERROR:
      blinkErrorLED();
      break;
  }
}

// ============================================================================
// IMU Setup
// ============================================================================

void setupIMU() {
#if DEBUG_EN
  Serial.println(F("Initializing ICM-20948..."));
#endif

  // Initialize with default I2C address (0x68 or 0x69)
  if (!imu.begin()) {
#if DEBUG_EN
    Serial.println(F("ICM-20948 not found!"));
#endif
    // Blink LED rapidly to indicate error
    while (1) {
      digitalWrite(LED_PIN, HIGH);
      delay(100);
      digitalWrite(LED_PIN, LOW);
      delay(100);
    }
  }

  // Configure accelerometer: ±4g range
  imu.setAccelRange(ICM20948_ACCEL_RANGE_4G);

  // Configure gyroscope: ±500 deg/s range
  imu.setGyroRange(ICM20948_GYRO_RANGE_500DPS);

  // Configure sample rate
  imu.setSampleRate(IMU_UPDATE_RATE_HZ);

  // Enable magnetometer
  imu.enableMagnetometer();

#if DEBUG_EN
  Serial.println(F("ICM-20948 initialized"));
#endif
}

// ============================================================================
// Protocol Messages
// ============================================================================

uint8_t computeChecksum(const char *str) {
  uint8_t checksum = 0;
  while (*str) {
    checksum ^= *str++;
  }
  return checksum;
}

void sendMessage(const char *payload) {
  uint8_t checksum = computeChecksum(payload);
  char msg[128];
  snprintf(msg, sizeof(msg), "$%s*%02X\r\n", payload, checksum);
  Serial.print(msg);
}

void sendVersion() {
  char payload[64];
  snprintf(payload, sizeof(payload), "VER,%s", GIT_SHA1_VERSION);
  sendMessage(payload);
}

void sendReady() {
  sendMessage("RDY");
}

void sendAck() {
  sendMessage("ACK");
}

void sendError(const char *msg) {
  char payload[64];
  snprintf(payload, sizeof(payload), "ERR,%s", msg);
  sendMessage(payload);
}

void sendMagCalValues() {
  char payload[96];
  snprintf(payload, sizeof(payload), "MGC,%.2f,%.2f,%.2f,%.3f,%.3f,%.3f",
           magCal.offsetX, magCal.offsetY, magCal.offsetZ,
           magCal.scaleX, magCal.scaleY, magCal.scaleZ);
  sendMessage(payload);
}

void sendOffsetResponse() {
  char payload[64];
  snprintf(payload, sizeof(payload), "OFS,%.3f,%.3f,%.3f",
           offsetCal.x, offsetCal.y, offsetCal.z);
  sendMessage(payload);
}

// ============================================================================
// Configuration Timeout
// ============================================================================

void checkConfigTimeout() {
  if (millis() - configTimeoutStart > CONFIG_TIMEOUT_MS) {
    currentState = IMUState::ERROR;
    sendError("CONFIG_TIMEOUT");
  }
}

void blinkErrorLED() {
  static uint32_t lastBlink = 0;
  uint32_t now = millis();
  if (now - lastBlink > 200) {
    digitalWrite(LED_PIN, !digitalRead(LED_PIN));
    lastBlink = now;
  }
}

// ============================================================================
// Calibration
// ============================================================================

void startCalibration() {
  calibrating = true;
  calibrationStartTime = millis();

  // Reset min/max
  magMin[0] = magMin[1] = magMin[2] = 99999;
  magMax[0] = magMax[1] = magMax[2] = -99999;

  currentState = IMUState::CALIBRATING;
  sendAck();

#if DEBUG_EN
  Serial.println(F("Calibration started - rotate sensor slowly"));
#endif
}

void updateCalibration(float mx, float my, float mz) {
  // Track min/max for each axis
  if (mx < magMin[0]) magMin[0] = mx;
  if (mx > magMax[0]) magMax[0] = mx;
  if (my < magMin[1]) magMin[1] = my;
  if (my > magMax[1]) magMax[1] = my;
  if (mz < magMin[2]) magMin[2] = mz;
  if (mz > magMax[2]) magMax[2] = mz;

  // Auto-finish after calibration duration
  if (millis() - calibrationStartTime > CALIBRATION_DURATION_MS) {
    finishCalibration();
    sendMagCalValues();
    currentState = IMUState::WAITING_FOR_CONFIG;
    configTimeoutStart = millis();  // Reset timeout after calibration
  }
}

void finishCalibration() {
  calibrating = false;

  // Calculate hard-iron offsets (center of min/max)
  magCal.offsetX = (magMin[0] + magMax[0]) / 2;
  magCal.offsetY = (magMin[1] + magMax[1]) / 2;
  magCal.offsetZ = (magMin[2] + magMax[2]) / 2;

  // Calculate soft-iron scale factors
  float rangeX = magMax[0] - magMin[0];
  float rangeY = magMax[1] - magMin[1];
  float rangeZ = magMax[2] - magMin[2];
  
  // Avoid division by zero
  if (rangeX < 0.001f) rangeX = 0.001f;
  if (rangeY < 0.001f) rangeY = 0.001f;
  if (rangeZ < 0.001f) rangeZ = 0.001f;
  
  float avgRange = (rangeX + rangeY + rangeZ) / 3;

  magCal.scaleX = avgRange / rangeX;
  magCal.scaleY = avgRange / rangeY;
  magCal.scaleZ = avgRange / rangeZ;
  magCal.valid = true;

#if DEBUG_EN
  Serial.println(F("Calibration complete"));
  Serial.print(F("Offsets: "));
  Serial.print(magCal.offsetX);
  Serial.print(F(", "));
  Serial.print(magCal.offsetY);
  Serial.print(F(", "));
  Serial.println(magCal.offsetZ);
#endif
}

// ============================================================================
// IMU Update
// ============================================================================

void updateIMU() {
  if (!imu.dataReady()) return;

  imu.read();

  // Get scaled values
  float ax = imu.accelX(); // g
  float ay = imu.accelY();
  float az = imu.accelZ();

  float gx = imu.gyroX(); // deg/s
  float gy = imu.gyroY();
  float gz = imu.gyroZ();

  float mx = imu.magX(); // uT
  float my = imu.magY();
  float mz = imu.magZ();

  // Apply magnetometer calibration or collect calibration data
  if (calibrating) {
    updateCalibration(mx, my, mz);
  } else if (magCal.valid) {
    mx = (mx - magCal.offsetX) * magCal.scaleX;
    my = (my - magCal.offsetY) * magCal.scaleY;
    mz = (mz - magCal.offsetZ) * magCal.scaleZ;
  }

  // Update Madgwick filter
  filter.update(gx, gy, gz, ax, ay, az, mx, my, mz);

  loopCount++;
}

// ============================================================================
// Acceleration Offset Correction
// ============================================================================

void correctAccelForOffset(float &ax, float &ay, float &az,
                           float gx, float gy, float gz,
                           float alpha_x, float alpha_y, float alpha_z) {
  // Skip correction if offset is zero (common case)
  if (offsetCal.x == 0.0f && offsetCal.y == 0.0f && offsetCal.z == 0.0f) {
    return;
  }

  // Convert angular rates from deg/s to rad/s
  const float DEG_TO_RAD = 0.017453292519943295f;
  float wx = gx * DEG_TO_RAD;
  float wy = gy * DEG_TO_RAD;
  float wz = gz * DEG_TO_RAD;

  // Convert angular accelerations from deg/s² to rad/s²
  float ax_rad = alpha_x * DEG_TO_RAD;
  float ay_rad = alpha_y * DEG_TO_RAD;
  float az_rad = alpha_z * DEG_TO_RAD;

  // Offset vector (meters)
  float dx = offsetCal.x;
  float dy = offsetCal.y;
  float dz = offsetCal.z;

  // Centripetal acceleration: a_c = omega x (omega x r)
  float cent_x = wy * (wy * dx - wx * dy) + wz * (wz * dx - wx * dz);
  float cent_y = wx * (wx * dy - wy * dx) + wz * (wz * dy - wy * dz);
  float cent_z = wx * (wx * dz - wz * dx) + wy * (wy * dz - wz * dy);

  // Tangential acceleration: a_t = alpha x r
  float tang_x = ay_rad * dz - az_rad * dy;
  float tang_y = az_rad * dx - ax_rad * dz;
  float tang_z = ax_rad * dy - ay_rad * dx;

  // Subtract spurious accelerations
  ax -= (cent_x + tang_x);
  ay -= (cent_y + tang_y);
  az -= (cent_z + tang_z);
}

// ============================================================================
// Serial Output
// ============================================================================

void outputIMUData() {
  uint32_t now = micros();

  // Get orientation from filter
  float heading = filter.getYaw();
  float pitch = filter.getPitch();
  float roll = filter.getRoll();

  // Get rates directly from gyro
  float gx = imu.gyroX();
  float gy = imu.gyroY();
  float gz = imu.gyroZ();

  float yawRate = gz;
  float pitchRate = gy;
  float rollRate = gx;

  // Get accelerations in m/s²
  float ax = imu.accelX() * 9.81f;
  float ay = imu.accelY() * 9.81f;
  float az = imu.accelZ() * 9.81f;

  // Calculate angular acceleration for offset correction
  float alpha_x = 0, alpha_y = 0, alpha_z = 0;
  if (prevGyroTime > 0) {
    float dt = (now - prevGyroTime) / 1000000.0f;
    if (dt > 0 && dt < 0.1f) {
      alpha_x = (gx - prevGyroX) / dt;
      alpha_y = (gy - prevGyroY) / dt;
      alpha_z = (gz - prevGyroZ) / dt;
    }
  }

  prevGyroX = gx;
  prevGyroY = gy;
  prevGyroZ = gz;
  prevGyroTime = now;

  // Apply offset correction
  correctAccelForOffset(ax, ay, az, gx, gy, gz, alpha_x, alpha_y, alpha_z);

  // Build and send message
  char payload[120];
  snprintf(payload, sizeof(payload),
           "IMU,%.1f,%.1f,%.1f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f",
           heading, pitch, roll, yawRate, pitchRate, rollRate, ax, ay, az);
  sendMessage(payload);
}

// ============================================================================
// Command Processing (Configuration Phase Only)
// ============================================================================

void processConfigCommands() {
  while (Serial.available()) {
    char c = Serial.read();

    if (c == '$') {
      // Start of command
      cmdIndex = 0;
    } else if (c == '\n' || c == '\r') {
      // End of command
      if (cmdIndex == 0) continue;  // Empty command
      
      cmdBuffer[cmdIndex] = '\0';

      // Remove checksum if present
      char *star = strchr(cmdBuffer, '*');
      if (star) *star = '\0';

      // Parse commands
      if (strncmp(cmdBuffer, "START", 5) == 0) {
        // Enter streaming mode
        sendAck();
        currentState = IMUState::STREAMING;
        lastIMUUpdate = micros();
        lastSerialOutput = micros();
      }
      else if (strncmp(cmdBuffer, "OFF,", 4) == 0) {
        // Set offset: OFF,x,y,z
        char *ptr = cmdBuffer + 4;
        char *endptr;

        float x = strtod(ptr, &endptr);
        if (*endptr == ',') {
          ptr = endptr + 1;
          float y = strtod(ptr, &endptr);
          if (*endptr == ',') {
            ptr = endptr + 1;
            float z = strtod(ptr, &endptr);

            offsetCal.x = x;
            offsetCal.y = y;
            offsetCal.z = z;
            sendOffsetResponse();
            configTimeoutStart = millis();  // Reset timeout
          } else {
            sendError("PARSE_OFF");
          }
        } else {
          sendError("PARSE_OFF");
        }
      }
      else if (strncmp(cmdBuffer, "MAG,", 4) == 0) {
        // Set mag calibration: MAG,ox,oy,oz,sx,sy,sz
        char *ptr = cmdBuffer + 4;
        char *endptr;
        float values[6];
        bool ok = true;

        for (int i = 0; i < 6 && ok; i++) {
          values[i] = strtod(ptr, &endptr);
          if (i < 5) {
            if (*endptr == ',') {
              ptr = endptr + 1;
            } else {
              ok = false;
            }
          }
        }

        if (ok) {
          magCal.offsetX = values[0];
          magCal.offsetY = values[1];
          magCal.offsetZ = values[2];
          magCal.scaleX = values[3];
          magCal.scaleY = values[4];
          magCal.scaleZ = values[5];
          magCal.valid = true;
          sendMagCalValues();
          configTimeoutStart = millis();  // Reset timeout
        } else {
          sendError("PARSE_MAG");
        }
      }
      else if (strncmp(cmdBuffer, "CAL,START", 9) == 0) {
        // Start interactive calibration
        if (currentState == IMUState::WAITING_FOR_CONFIG) {
          startCalibration();
        } else {
          sendError("INVALID_STATE");
        }
      }
      else if (strncmp(cmdBuffer, "CAL,STOP", 8) == 0) {
        // Stop calibration
        if (currentState == IMUState::CALIBRATING) {
          finishCalibration();
          sendMagCalValues();
          currentState = IMUState::WAITING_FOR_CONFIG;
          configTimeoutStart = millis();  // Reset timeout
        } else {
          sendError("NOT_CALIBRATING");
        }
      }
      else {
        sendError("UNKNOWN_CMD");
      }

      cmdIndex = 0;
    } else if (cmdIndex < sizeof(cmdBuffer) - 1) {
      cmdBuffer[cmdIndex++] = c;
    }
  }
}
